---
title: Decentralized storage
description: Learn about decentralized storage works and how it's key to NFT.Storage.
---



# Decentralized storage in brief

NFT.Storage relies on _decentralized storage_ to store your files for free on the network. **Decentralized storage is a technique for storing data that, instead of traditional servers, uses a distributed network with many participants providing storage capacity.** This model inherently builds in redundancy that provides resilience against failure and attacks, as well as enhanced performance due to the geographical localization offered by a large network of distributed storage providers. While you don't need to understand decentralized storage to be able to incorporate NFT.Storage in your apps and services, if you're curious about what's going on under the hood, read on.

## Content addressing

Broadly speaking, much of today's web operates using what is known as _location addressing_. Location addressing retrieves online information from specific locations on the web ─ i.e. from behind URLs.

```
https://example.com/page-one.html
```

However, this approach has some critical problems. Location addressing is _centralized_, meaning that **whoever controls that location controls the content**. The controller can change the content, completely replace it, or just take it away. This means location-based addresses are vulnerable to attacks, exploitation, and loss.

One part of an approach to _decentralizing_ this legacy way of operating the web entails implementing a new kind of addressing: _content addressing_. Content addressing is the technique of issuing each piece of data a _content identifier (CID)_, which is a token derived directly from the file's contents using an algorithm that will always generate the same key for the same content. Using content addressing, files can be queried and retrieved based on _what they are_, not _where they are_ — one major ingredient in enabling the web to break free from centralized content control.

NFT.Storage uses CIDs generated by [IPFS](https://ipfs.io), the InterPlanetary File System, to enable content addressing for all data stored. This computation is generally done on the user's (client) side, meaning users don't have to trust NFT.Storage to know they have the correct CID. And as long as CIDs are used to reference off-chain data in an NFT, there can't be a dispute to what content (art, videos, etc.) an NFT is referring to - you can just verify content against ithe CID!

However, content addressing is only part of the solution. IPFS references data via its CID and makes sure you can get the content back as long as at least one copy is being broadcast to the network. BUt **just because a file has a CID doesn't mean that the file is guaranteed to be around forever**. In a well-operating decentralized system, participants all need to agree to be good actors and provide reliable storage capacity. For this, NFT.Storage uses the [Filecoin](https://filecoin.io) network. The Filecoin network and its namesake token FIL (or ⨎ for short) were created to incentivize storage providers on the network to agree to _storage deals_, and provide trustless proof that the storage providers are actually storing the data as promised. These deals specify that a certain amount of storage capacity will be provided over an agreed period of time, ensuring the second part of the solution: _content persistence_.

## Filecoin for verifiable content persistence

Leveraging the Filecoin network for data stored using NFT.Storage ensures that content is available for retrieval, thus assuring that the content-based addressing provided by IPFS remains resilient over time. Filecoin achieves this mission using a number of methods, including [novel cryptography, consensus protocols, and game-theoretic incentives](https://filecoin.io/blog/posts/filecoin-features-verifiable-storage/) — but perhaps the most important of these is Filecoin's unique approach to storage verification.

Filecoin's storage verification system solves a previously intractable problem for decentralized storage: How can storage providers _prove_ that they are really storing the data they say they are over time? Filecoin's [proving algorithms](https://filecoin.io/blog/posts/what-sets-us-apart-filecoin-s-proof-system/) take care of this verification: 
- [_Proof-of-Replication_](https://proto.school/verifying-storage-on-filecoin/03) proves that a given storage provider is storing a unique copy of a client's original data.
- [_Proof-of-Spacetime_](https://proto.school/verifying-storage-on-filecoin/04) proves that the client's data is stored continuously over time.

Since these proofs end up on-chain, anyone can look at the Filecoin blockchain and verify that a given piece of content was being stored for this duration of time by these storage providers.

In addition to this proof system, the Filecoin network also relies on _game-theoretic incentives_ to discourage malicious or negligent activity. In order to become a Filecoin storage provider, all potential providers must provide collateral in the form of FIL when agreeing to a storage deal. Additionally, any storage provider that fails Proof-of-Spacetime checks is penalized, loses a portion of their collateral, and is eventually prevented from offering storage to clients again.

## Storing and monitoring with NFT.Storage

How can you see these principles in action with your files uploaded to NFT.Storage? It's easy using the NFT.Storage [JavaScript client library](https://nftstorage.github.io/nft.storage/client/).

When you upload a file to NFT.Storage, you get the CID of that file in return. The file is then put into a queue for geographically distributed Filecoin network storage providers who have been chosen for performance and availability. These providers bid on the right to store the files in the queue — including your file — and agree to a storage deal.

You can monitor this activity for files you upload to NFT.Storage by [calling `check()`](https://nftstorage.github.io/nft.storage/client/classes/lib.NFTStorage.html#check) and providing a file's CID. This will return a list of deals that have been made at the time of query. Here's how you might include this call in your JavaScript project:

```js
const cid = 'bafybeiggzq4ryi7hscq5hzvzcnk4urnxt3asp37dhgvnjilf7exskximla'

// check status based on CID
const info = await client.check(rootCid)

// display results of query
console.log(`${info.cid}`)
for (const deal of info.deals) {
  console.log(deal)
}
```

And you can always verify this data by using a Filecoin block explorer like [Filfox](https://filfox.info/en)!

## Fully decentralizing NFT.Storage for multigenerational storage

Persisting off-chain NFT data can fall prey to the "tragedy of the commons." Ultimately, the owner of an NFT is responsible to make sure the off-chain component of their NFT exists and is accessible, and this culture is growing in the NFT space - but in practice, it can be somewhat complicated to make sure off-chain data is always persisted. This is why NFT.Storage has the mission to [store all NFT data as a public good](https://nft.storage/blog/post/2022-01-20-decentralizing-nft-storage/). But how will this work?

Individual Filecoin deals are a building block for any decentralized storage system. The Filecoin chain trustlessly shows that specific content is persisted, the number of copies of this content on the network, and with who it is stored with. As a result, you can instrument smart contracts to listen to the chain and enforce things like long-term redundancy. Today, NFT.Storage is manually renewing individual Filecoin deals, but soon, it will use the [FVM](https://fvm.filecoin.io/) to achieve multigenerational, decentralized persistence. The current plan is to create a "data DAO" that funds smart contracts that perpetually ensure many copies of data uploaded to NFT.Storage exist, and create new storage deals if storage deals expire or copies go away.

However, by using IPFS CIDs to address data, users don't need to rely just on NFT.Storage's persistence model to keep their NFTs safe. We encourage users to save their NFTs in as many places as makes them feel comfortable (we call this ["storage layer maximalism"](https://nft.storage/blog/post/2021-12-14-storage-layer-maximalism/)). Having this culture also contributes to the decentralized storage of NFTs as a public good!

## Summary

The legacy approach of using location addressing to reference files on the web has a number of critical vulnerabilities to interference, exploitation, and loss. Because whoever controls the location controls the content, these location-addressed, centrally stored networks also leave the web exposed to the whims of big, corporate central storage platforms.

By pairing IPFS content addressing (to decentralize how resources are specified) with Filecoin (to decentralize how storage capacity is obtained), it becomes possible to create a complete solution for locating, storing, and obtaining data — one that is not only resilient against these vulnerabilities, but also rewarding for network participants.


## Learn more

Want a deep dive into decentralized storage, how it works, and why it's important? Check out [ProtoSchool](https://proto.school/verifying-storage-on-filecoin/) for an in-depth look at verifying storage on Filecoin, plus a wealth of other interactive tutorials on DWeb concepts, protocols, and tools.
